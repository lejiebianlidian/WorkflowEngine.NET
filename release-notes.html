<h1>Workflow Engine: Release Notes</h1>
<h2>4.1 {#4.1}</h2>
<ul>
<li>
<p>Support for multi-tenant applications.</p>
<ul>
<li>
<p><em>TenantId</em> has been added to processes. When creating a process, one can specify <em>TenantId</em> and use its value when working with the process. <em>TenantId</em> is stored in the <em>WorkflowProcessInstance</em> table in the <em>TenantId</em> column.
Passing <code>TenantId</code> to a process:</p>
<pre><code class="language-csharp">var createInstanceParams = new CreateInstanceParams(schemeCode, processId) { TenantId = &quot;tenantId&quot; };
workflowRuntime.CreateInstance(createInstanceParams);
</code></pre>
<p>After creating a process with <em>TenantId</em> indicated, the access to it inside <em>Actions</em>, <em>Conditions</em> and <em>Rules</em> can be arranged as follows.</p>
<pre><code class="language-csharp">string tenantId = processInstance.TenantId;
</code></pre>
</li>
<li>
<p>For schemes one can specify tags, and then, search for schemes where these tags are indicated. Tags are set in the scheme designer by clicking on the <em>Process Info</em> button. Tags are stored in the <em>WorkflowScheme</em> table in the <em>Tags</em> column. A list of codes for the schemes where the corresponding tags are indicated can be received using the following code:</p>
<pre><code class="language-csharp">List&lt;string&gt; schemeCodes =  workflowRuntime.Builder.SearchSchemesByTags(new List&lt;string&gt; {&quot;Tag1&quot;,&quot;Tag2&quot;});
</code></pre>
</li>
</ul>
<p>The search is performed using an OR expression.</p>
</li>
<li>
<p>Plugin System and the Basic Plugin. The plugin for WorkflowEngine.NET is a class that is necessary to implement the <code>IWorkflowPlugin</code> interface, and optional to implement the <code>IWorkflowActionProvider</code>, <code>IWorkflowRuleProvider</code>, <code>IDesignerParameterFormatProvider</code>, <code>IDesignerAutocompleteProvider</code> interfaces (in any combination). In fact, the plugin is a class that adds functionality to be used when creating process schemes. The plugin connects to WorkflowEngine.NET when configuring <code>WorkflowRuntime</code>.</p>
<pre><code class="language-csharp">WorkflowRuntime workflowRuntime = workflowRuntime.WithPlugin(new BasicPlugin());
</code></pre>
<p>Simultaneously, any number of plugins can be connected to WorkflowEngine.NET. The Basic Plugin <code>OptimaJet.Workflow.Core.Plugins.BasicPlugin</code> has been added to the WorkflowEngine.NET package; it implements the following basic functions:</p>
<ul>
<li>Actions:
<ul>
<li><em>SendEmail</em> - sending email.</li>
<li><em>CreateProcess</em> - creating a process from a process.</li>
<li><em>HTTPRequest</em> - sending a request to a third-party web service.</li>
<li><em>SetParameter</em> - setting a process parameter.</li>
</ul>
</li>
<li>Conditions:
<ul>
<li><em>IsProcessFinalized</em> - checking the finalization of the current process or a process with the Id specified.</li>
<li><em>CheckAllSubprocessesCompleted</em> - checking the finalization (completion) of all the subprocesses.</li>
<li><em>CheckParameter</em> - checking if the parameter is consistent to the given value (so far, only strings are supported).</li>
<li><em>IsArrovedByUsers</em> - checking if the specified process was processed by all of the listed users.</li>
<li><em>IsArrovedByRoles</em> - checking if the specified process was processed by all of the listed roles.</li>
<li><em>CheckHTTPRequest</em> - conditional transition based on the result of a request to a third-party web service.</li>
</ul>
</li>
<li>Authorization Rules (Security):
<ul>
<li><em>CheckRole</em> - checking access to the command for a specific role.
<strong>Warning: to perform operations related to the roles checking, <code>BasicPlugin</code> must have the delegate handler <code>basicPlugin.UsersInRoleAsync</code> installed.</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Now, implicit (that is, not explicitly specified in the scheme) parameters passed when creating a process, executing a command, or setting a new state to a process can be persistent.</p>
<ul>
<li>
<p>When creating a process, use the following code:</p>
<pre><code class="language-csharp">var createInstanceParams = new CreateInstanceParams(schemeCode, processId)
  .AddPersistentParameter(&quot;Parameter1Name&quot;, 100)
  .AddPersistentParameter(&quot;ParameterName2&quot;, parameterValue);
workflowRuntime.CreateInstance(createInstanceParams);
</code></pre>
</li>
<li>
<p>When passing parameters with a command, use the following code:</p>
<pre><code class="language-csharp">WorkflowCommand command = ...
command.SetParameter(&quot;ParameterName&quot;, parameterValue, persist: true);
workflowRuntime.ExecuteCommand(command, ... );
</code></pre>
</li>
<li>
<p>When passing a parameter with a command, use the following code:</p>
<pre><code class="language-csharp">var setStateParams = new SetStateParams(processId,&quot;StateName&quot;)
  .AddPersistentParameter(&quot;Parameter1Name&quot;, 100)
  .AddPersistentParameter(&quot;ParameterName2&quot;, parameterValue);
workflowRuntime.SetState(setStateParams);
</code></pre>
</li>
</ul>
</li>
<li>
<p>Support for dynamic parameters has been added. To perform the task, the <code>DynamicParameter</code> class, which can be cast into dynamic, has been developed. For example:</p>
<p>Creating a parameter:</p>
<pre><code class="language-csharp">var dynamicParameter = new
{
  Name = &quot;Dynamic&quot;,
  ObjectValue = new
  {
      Name = &quot;Object&quot;,
      Value = 100
  },
  ListValue = new List&lt;object&gt; {
      new {Id = 1, Name = &quot;ObjectInList1&quot;},
      new {Id = 2, Name = &quot;ObjectInList2&quot;}
  }
}
processInstance.SetParameter(&quot;Dynamic&quot;, dynamicParameter, ParameterPurpose.Persistence);
</code></pre>
<p>Getting a parameter:</p>
<pre><code class="language-csharp">var dynamicParameter = processInstance.GetParameter&lt;DynamicParameter&gt;(&quot;Dynamic&quot;) as dynamic;
string name = dynamicParameter.Name;
string objectValueName = dynamicParameter.ObjectValue.Name;
string firstItemName = (dynamicParameter.ListValue as List&lt;dynamic&gt;).First().Name;
</code></pre>
</li>
<li>
<p>The following aggregating providers are available: <code>AggregatingActionProvider</code>, <code>AggregatingRuleProvider</code>, <code>AggregatingDesignerAutocompleteProvider</code>, <code>AggregatingDesignerParameterFormatProvider</code>. An aggregating provider is a provider to which other providers can be added.</p>
</li>
<li>
<p><code>IWorkflowRuleProvider</code> - supports asynchronous authorization (security) rules.</p>
</li>
<li>
<p>The scheme code is passed to all methods of all providers. Here are these methods</p>
<ul>
<li><code>IWorkflowActionProvider.GetActions</code></li>
<li><code>IWorkflowActionProvider.GetConditions</code></li>
<li><code>IWorkflowActionProvider.IsActionAsync</code></li>
<li><code>IWorkflowActionProvider.IsConditionAsync</code></li>
<li><code>IWorkflowRuleProvider.GetRules</code></li>
<li><code>IWorkflowRuleProvider.IsCheckAsync</code></li>
<li><code>IWorkflowRuleProvider.IsGetIdentitiesAsync</code></li>
<li><code>IDesignerParameterFormatProvider.GetFormat</code></li>
<li><code>IDesignerAutocompleteProvider.GetAutocompleteSuggestions</code></li>
</ul>
<p><code>string schemeCode</code> has been added as the last parameter to all these methods.</p>
</li>
<li>
<p>A unified and correct error output when accessing the Designer API has been added.</p>
</li>
<li>
<p>Intellisense has been added in the Code Actions (code in schemes) editor.</p>
</li>
<li>
<p>A new type <em>TextArea</em> has been added to the forms where parameter (for Actions, Conditions or rules) values are edited.</p>
</li>
<li>
<p>In any of the persistence providers, one can optionally turn off the history of transitions and set the history of subprocesses to be written in the history of the main process. For example:</p>
<pre><code class="language-csharp">var provider = new MSSQLProvider(connectionString, writeToHistory:false);
var provider = new MSSQLProvider(connectionString, writeSubProcessToRoot:true);
</code></pre>
</li>
</ul>
<p><strong>The following additional actions must be taken to upgrade to Workflow Engine 4.1:</strong></p>
<ul>
<li>
<p>Run the SQL script update_2_7_to_2_8.sql for all relative databases.</p>
<ul>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Providers/NETCore_OptimaJet.Workflow.MSSQL/Scripts/update_4_0_to_4_1.sql">MSSQL</a></li>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Providers/NETCore_OptimaJet.Workflow.PostgreSQL/Scripts/update_4_0_to_4_1.sql">PostgreSQL</a></li>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Providers/NETCore_OptimaJet.Workflow.Oracle/Scripts/update_4_0_to_4_1.sql">Oracle</a></li>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Providers/NETCore_OptimaJet.Workflow.MySQL/Scripts/update_4_0_to_4_1.sql">MySQL</a></li>
</ul>
</li>
<li>
<p>Update all files related to the Designer. They are available <a href="https://github.com/optimajet/WorkflowEngine.NET/tree/master/Designer">here</a>.</p>
</li>
<li>
<p>Update packages or dll to version 4.1.</p>
</li>
<li>
<p>If the <code>IWorkflowActionProvider</code> interface is implemented in your project, the last parameter<code>string schemeCode</code> shall be added to the following methods:</p>
<ul>
<li><code>IWorkflowActionProvider.GetActions</code></li>
<li><code>IWorkflowActionProvider.GetConditions</code></li>
<li><code>IWorkflowActionProvider.IsActionAsync</code></li>
<li><code>IWorkflowActionProvider.IsConditionAsync</code></li>
</ul>
</li>
<li>
<p>If the <code>IWorkflowRuleProvider</code> interface is implemented in your project, the following methods shall be added to your provider:</p>
<pre><code class="language-csharp">public Task&lt;bool&gt; CheckAsync(ProcessInstance processInstance, WorkflowRuntime runtime, string identityId, string ruleName,string parameter, CancellationToken token)
{
    throw new NotImplementedException();
}

public Task&lt;IEnumerable&lt;string&gt;&gt; GetIdentitiesAsync(ProcessInstance processInstance, WorkflowRuntime runtime, string ruleName, string parameter, CancellationToken token)
{
    throw new NotImplementedException();
}

public bool IsCheckAsync(string ruleName, string schemeCode)
{
    return false;
}

public bool IsGetIdentitiesAsync(string ruleName, string schemeCode)
{
    return false;
}
</code></pre>
<p>The last parameter <code>string schemeCode</code> shall be also added to the following method:</p>
<ul>
<li><code>IWorkflowRuleProvider.GetRules</code></li>
</ul>
</li>
<li>
<p>If the <code>IDesignerParameterFormatProvider</code> interface is implemented in your project, the last parameter <code>string schemeCode</code> shall be added to the following method:</p>
<ul>
<li><code>IDesignerParameterFormatProvider.GetFormat</code></li>
</ul>
</li>
<li>
<p>If the <code>IDesignerAutocompleteProvider</code> interface is implemented in your project, the last parameter <code>string schemeCode</code> shall be added to the following method:</p>
<ul>
<li><code>IDesignerAutocompleteProvider.GetAutocompleteSuggestions</code></li>
</ul>
</li>
<li>
<p><strong>IMPORTANT! Incorrect behavior was fixed when the subprocess was merged in the parent process via the set state of the parent process mechanism. Previously, the parent process parameters were OVERWRITTEN. Now, the parent process parameters won't be changed. Only new parameters from the subprocess will be written to the parent process automatically. The same way the merge via calculating conditions always works. If you consciously exploited this behavior, then the best way to get parameters from the subprocess is to use a property <code>processInstance.MergedSubprocessParameters</code> when merge occurs.</strong></p>
</li>
<li>
<p><strong>IMPORTANT! If in your project the Action Provider has changed (after the first initialization) using the method <code>workflowRuntime.WithActionProvider(...)</code> replace this code with the following call <code>workflowRuntime.ClearActionProvider().WithActionProvider(...)</code></strong></p>
</li>
<li>
<p><strong>IMPORTANT! If in your project the Rule Provider has changed (after the first initialization) using the method <code>workflowRuntime.WithRuleProvider(...)</code> replace this code with the following call <code>workflowRuntime.ClearRuleProvider().WithRuleProvider(...)</code></strong></p>
</li>
<li>
<p><strong>IMPORTANT! If in your project the Designer Autocomplete Provider has changed (after the first initialization) using the method <code>workflowRuntime.WithDesignerAutocompleteProvider(...)</code> replace this code with the following call <code>workflowRuntime.ClearDesignerAutocompleteProvider().WithDesignerAutocompleteProvider(...)</code></strong></p>
</li>
<li>
<p><strong>IMPORTANT! If in your project the Designer Parameter Format Provider has changed (after the first initialization) using the method <code>workflowRuntime.WithDesignerParameterFormatProvider(...)</code> replace this code with the following call <code>workflowRuntime.ClearDesignerParameterFormatProvider().WithDesignerParameterFormatProvider(...)</code></strong></p>
</li>
<li>
<p>It is not necessary but suggested to change the Designer Controller the following way</p>
<pre><code class="language-csharp">public ActionResult API()
{
  ...
  var res = WorkflowInit.Runtime.DesignerAPI(pars, out bool hasError, filestream, true);
  var operation = pars[&quot;operation&quot;].ToLower();

  if (operation == &quot;downloadscheme&quot; &amp;&amp; !hasError)
    return File(Encoding.UTF8.GetBytes(res), &quot;text/xml&quot;, &quot;scheme.xml&quot;);
  else if (operation == &quot;downloadschemebpmn&quot; &amp;&amp;  !hasError)
    return File(UTF8Encoding.UTF8.GetBytes(res), &quot;text/xml&quot;, &quot;scheme.bpmn&quot;);

  return Content(res);
}
</code></pre>
<p>See complete controller code</p>
<ul>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Samples/ASP.NET%20Core/MSSQL/WF.Sample/Controllers/DesignerController.cs">ASP.NET MVC Core</a></li>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Samples/ASP.NET%20MVC/MSSQL/WF.Sample/Controllers/DesignerController.cs">ASP.NET MVC</a></li>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Samples/ASP.NET%20WebForms/WebFormsMSSQL/WF.Sample/Pages/Designer/WFEDesigner.ashx.cs">Web Forms</a></li>
</ul>
</li>
<li>
<p>It is not necessary but suggested to pass the scheme code when calling <code>wfdesigner.create()</code> method on the Designer page.</p>
<pre><code class="language-javascript">wfdesigner.create(schemecode);
</code></pre>
<p>See complete view code</p>
<ul>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Samples/ASP.NET%20Core/MSSQL/WF.Sample/Views/Designer/Index.cshtml">ASP.NET MVC Core</a></li>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Samples/ASP.NET%20MVC/MSSQL/WF.Sample/Views/Designer/Index.cshtml">ASP.NET MVC</a></li>
<li><a href="https://github.com/optimajet/WorkflowEngine.NET/blob/master/Samples/ASP.NET%20WebForms/WebFormsMSSQL/WF.Sample/Pages/Designer/Index.aspx">Web Forms</a></li>
</ul>
</li>
</ul>
<h2>4.0 {#4.0}</h2>
<ul>
<li>Designer usability improvement. Transition info will now be displayed in a fuller, more comprehensive form. You can now switch between full screen and normal edit window display modes. Toolbars design has been changed.</li>
<li>you can customize Activity и Transition rendering in the Designer.</li>
<li>you can customize Designer windows.</li>
<li>Designer performance has been optimized.</li>
<li>Scheme inlining. Now you can check a scheme as a scheme that can be inlined and embed it into another scheme. Thus you can re-use typical parts of your processes many times, without copying them between schemes. Multi-layered inlining is supported.</li>
<li>Process Info window has been added into the specific process view mode. It allows you to view this process parameters, transition history, launched timers. Here full information on subprocesses is also displayed.</li>
<li>You can specify annotations for Activity and Transition. Annotations are a dictionary (key - value) which you can set in the Designer individually for each Activity ot Transition. You can read annotation value in the code, using the following methods: <code>activityDefinition.GetAnnotation&lt;T&gt;(name)</code>, <code>transitionDefinition.GetAnnotation&lt;T&gt;(name)</code>, <code>processInstance.ProcessScheme.GetActivityAnnotation&lt;T&gt;(activityName, name)</code>, <code>processInstance.ProcessScheme.GetTransitionAnnotation&lt;T&gt;(transitionName, name)</code></li>
<li>For the string parameter, which is transferred into Actions, Conditions and Rules, you can specify the structure which will define the form in which this parameter will be displayed in edit mode in the Designer. Form field contents can be specified in the Designer in the <code>CodeActions</code> section. Or you can create a class implementing <code>IDesignerParameterFormatProvider</code> interface on the server and configure your  <code>WorkflowRuntime</code> in the following way: <code>workflowRuntime.WithDesignerParameterFormatProvider(new YourDesignerParameterFormatProvider())</code>. Thus you can specify the appearance of the string parameter which is transferred into Action, Condition or Rule.</li>
<li>In the event handler <code>workflowRuntime.OnWorkflowError</code> you can now cancel exception throwing, using event arguments <code>args.SuppressThrow = true;</code>. Also you can specify the Activity, which will be set after error processing. For example, it can be initial activity: <code>args.ActivityToSet = args.ProcessInstance.ProcessScheme.InitialActivity;</code></li>
<li>For simple execution of complex business cases in <code>WorkflowRuntime</code> use two of the following methods: <code>workflowRuntime.GetAvailableCommandsWithConditionCheck(...)</code> - get the list of available commands with additional conditions check, and <code>workflowRuntime.ExecuteCommandWithRestrictionCheck(...)</code> - execution of the command with additional restrictions check.</li>
<li>Correct merging of the subprocess и parent process has been added, when a subprocess is merged with its parent process immediately after launch. In other words, if a subprocess contains only Auto triggered transitions. Now merge will be correct, and the subprocess will wait till the parent process is unlocked.</li>
<li>Process execution can be cancelled using <code>CancellationToken</code>. Such cancellation will be activated automatically if you configure your <code>WorkflowRuntime</code> in the following way: <code>workflowRuntime.SetCancellationTokenHandling(CancellationTokenHandling.Throw)</code>.</li>
</ul>
<p><strong>The following additional actions must be taken to upgrade to Workflow Engine 4.0:</strong></p>
<ul>
<li>Run the SQL  script <code>update_4_0.sql</code> for all relative databases. You will find this script in your provider's archive.</li>
<li>If you have used process status change (for example <code>args.ProcessStatus = ProcessStatus.Idled;</code>) to cancel exception release after the event has been processed <code>workflowRuntime.OnWorkflowError</code>, you will need to use the following code <code>args.SuppressThrow = true;</code>. Status change hack won't work, custom status will be installed, but the exception will still be thrown.</li>
</ul>
<h2>3.5 {#3.5}</h2>
<ul>
<li>Moving the canvas (in the Move mode) with arrows was added to the designer.</li>
<li>Explicit passing of CultureInfo was added to methods <code>GetInitialCommands</code>, <code>GetInitialState</code>, <code>GetCurrentState</code> and <code>GetAvailableCommands</code> of the <code>WorkflowRuntime</code> class</li>
<li>Full samples (Vacation request approval) for all supported databases for ASP.NET Core and ASP.NET MVC. Full samples for MSSQL, Postgres and Oracle database for Web Forms.</li>
</ul>
<h2>3.4 {#3.4}</h2>
<ul>
<li>Added automatic size increase for background in designer.</li>
<li>Added designer localization files for German, French, Spanish, Italian, Portuguese, Turkish, and Russian languages.</li>
<li>.NET Core NuGet packages come with .NET Standard 1.6 and .NET Standard 2.0 libraries. This allows you to use these packages with any .NET Core version, including 2.1.</li>
<li>The <code>OptimaJet.Workflow.Core.Logging.ILogger</code> interface was added; it can be initializes with your own logger in the <code>WorkflowRuntime</code> object. It is used to integrate with the Workflow Server logging system, but you can use it to integrate with your own system. Bear in mind that the logger in the <code>WorkflowRuntime</code> object is not initialized by anything by default.</li>
</ul>
<h2>3.3 {#3.3}</h2>
<ul>
<li>MongoDB provider for Workflow Engine .NET Core was added.</li>
<li>MongoDB driver was updated to version 2.7. You can now connect to CosmosDB through a MongoDB connection.</li>
<li>The following hotkeys were added to the Workflow Designer:
<ul>
<li>Ctrl + A - Select all</li>
<li>Ctrl + C - Copy selected items</li>
<li>Ctrl + E - New Activity</li>
<li>Ctrl + I - Extended info</li>
<li>Ctrl + Y - Redo</li>
<li>Ctrl + Z - Undo</li>
<li>Arrows - Move selected items</li>
<li>Delete - Delete</li>
<li>Alt + Enter - Full-screen mode</li>
<li>Ctrl + M - Move mode</li>
</ul>
</li>
</ul>
<p><strong>The following additional actions must be taken to upgrade to Workflow Engine 3.3 if you are using MongoDB:</strong></p>
<ul>
<li>Only for MongoDB users: it is necessary to apply the <em>update_3_2_to_3_3.js</em> script to your database.</li>
</ul>
<h2>3.2 {#3.2}</h2>
<ul>
<li>Added providers for MySQL and Oracle, running under .NET Core</li>
<li>Added class <code>AggregatingRuleProvider</code>, designed to combine several <code>IWorkflowRuleProvider</code> into one <code>IWorkflowRuleProvider</code>.</li>
<li>Added class <code>AggregatingActionProvider</code>, designed to combine several <code>IWorkflowActionProvider</code> into one <code>IWorkflowActionProvider</code>.</li>
</ul>
<h2>3.1 {#3.1}</h2>
<ul>
<li>Workflow Engine's relational database storage system has been optimized. Additional indices have been built; obsolete indices have been removed; the size of some columns has been changed. Generally, these changes should result in the improvement of Workflow Engine's performance, especially for Microsoft SQL Server. All these changes have already been included into installation scripts; use the <em>update_3_1.sql</em> script to update the existing databases.</li>
<li>BulkCreateInstance now works for Microsoft SQL Server and .NET Core (version &gt;= 2).</li>
</ul>
<p><strong>Warning</strong></p>
<p>The <em>update_3_1.sql</em> script contains a change of index and size of certain columns. Be particularly careful when applying it to the production database.</p>
<h2>3.0 {#3.0}</h2>
<ul>
<li>The interface of Workflow Designer has been revamped to improve usability
<ul>
<li>The look and feel of the scheme has been changed</li>
<li>The library that renders popup windows and controls has been changed from jQuery UI to <a href="https://github.com/Semantic-Org/Semantic-UI">Semantic-UI</a>. jQuery UI has been removed from the project completely. Autocomplete for lists has been implemented with <a href="https://github.com/Pixabay/jQuery-autoComplete">jQuery-autoComplete</a></li>
<li>The <a href="https://konvajs.github.io/">Konva.js</a> version has been updated to 2.0.2</li>
<li>The 'Extended Info' mode has been added to provide additional information needed when creating a workflow scheme</li>
<li>Undo and redo have been added</li>
<li>Current activity of subprocesses is now highlighted</li>
<li>Global CodeActions have been simplified</li>
<li>Scheme legend has been added</li>
</ul>
</li>
<li>Builds for .NET Core 2.0 and .NET Standard 2.0 have been included to .NET Core packages</li>
<li>The order of search for Action, Condition and Rule in Code Actions and <code>IWorkflowActionProvider</code>(<code>IWorkflowRuleProvider</code>) has been changed. Earlier on, the order was as follows (highest to lowest priority): Global CodeAction, CodeAction in the scheme, <code>IWorkflowActionProvider</code>(<code>IWorkflowRuleProvider</code>). Now this order is the following by default: CodeAction in the scheme, Global CodeAction, <code>IWorkflowActionProvider</code>(<code>IWorkflowRuleProvider</code>). Thus, CodeAction in the scheme has the highest priority. Search priority can be set with the <code>runtime.SetExecutionSearchOrder(ExecutionSearchOrder order)</code> setting.</li>
<li>Parameter type names used to be stored as an assembly qualified name (by specifying the version of the build and the public key token), which resulted in troubles when migrating schemes from the .NET Framework environment to the .NET Core environment. Now a simplified type name - the one that is displayed in Designer - is stored in the scheme. Old schemes are loaded without changes; type names will be replaced after the first save of the scheme in the Designer.</li>
<li>Errors that occur when there's a '-' in CodeAction names have been fixed.</li>
</ul>
<p><strong>The following additional actions must be taken to uprgade to Workflow Engine 3.0:</strong></p>
<ul>
<li>It is not necessary to update to the new version of the Designer; however, we strongly advise it. The old version of the Designer shall work with the new versions of the Workflow Engine at least within the next half a year. If you are updating to the new version of the Designer, introduce the following changes to the pages where Designer is displayed.
<ul>
<li>Delete links to <strong>jquery-ui.min.css</strong> and <strong>jquery-ui.js</strong></li>
</ul>
<pre><code class="language-html">		&lt;link href=&quot;/Content/themes/base/jquery-ui.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;
		&lt;script src=&quot;/Scripts/jquery-ui.js&quot; type=&quot;text/javascript&quot;/&gt;
		```
- Add links to **semantic.min.css**, **semantic.min.js**, **jquery.auto-complete.min.js**
		```html
		&lt;link href=&quot;/Content/semantic.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;
		&lt;script src=&quot;/Scripts/semantic.min.js&quot; type=&quot;text/javascript&quot;/&gt;
		&lt;script src=&quot;/Scripts/jquery.auto-complete.min.js&quot; type=&quot;text/javascript&quot;/&gt;
</code></pre>
</li>
<li>If the new order of search for Action, Condition and Rule does not suit you, change it with the following setting:</li>
</ul>
<pre><code class="language-csharp">runtime = runtime.SetExecutionSearchOrder(ExecutionSearchOrder.GlobalLocalProvider);
</code></pre>
<p>Then, everything shall work the same way it did in the previous versions.</p>
<ul>
<li>Workflow Engine's reaction to the scenario where it could not find an Action, Condition or Rule in CodeActions or <code>IWorkflowActionProvider</code>(<code>IWorkflowRuleProvider</code>) has been changed. Earlier on, Workflow Engine ignored this scenario which made it difficult to debug schemes. Now, the <code>NotImplementedException</code> exception is thrown, specifying the name of the object which was not found. If this behavior does not suit you, use the following setting:</li>
</ul>
<pre><code class="language-csharp">runtime = runtime.SetIgnoreMissingExecutionItems(true);
</code></pre>
<h2>2.3 {#2.3}</h2>
<ul>
<li>A 'Refresh' button and its functionality have been added to Designer</li>
<li>A 'Full Screen' button and its functionality have been added to Designer</li>
<li>BulkCreateInstance and TimerManager performance has been enhanced</li>
<li>Scroll-based scaling has been added to Designer</li>
</ul>
<h2>2.2 {#2.2}</h2>
<ul>
<li>Now it is possible to create asynchronous Actions and Conditions. You can call asynchronous methods from Actions and Conditions using the <code>await</code> keyword. Such methods will be the most effective if you use asynchronous methods of the <code>WorkflowRuntime</code> object, for example, <code>ExecuteCommandAsync</code> instead of <code>ExecuteCommand</code>, or <code>SetStateAsync</code> instead of <code>SetState</code>, etc. You can create asynchronous Actions in Designer. To do that you simply need to check the Async checkbox in the Action or Condition where you're going to call asynchronous methods from. If you use <code>IWorkflowActionProvider</code>, then you will need to implement 4 additional methods. <code>bool IsActionAsync(string name)</code> and <code>bool IsConditionAsync(string name)</code> should return true so that the Action or Condition are called asynchronously. The execution of an asynchronous Action or Condition is done in the <code>Task ExecuteActionAsync(string name, ProcessInstance processInstance, WorkflowRuntime runtime, string actionParameter, CancellationToken token)</code> and <code>Task&lt;bool&gt; ExecuteConditionAsync(string name, ProcessInstance processInstance, WorkflowRuntime runtime, string actionParameter, CancellationToken token)</code> methods.</li>
<li>Parameters conveyed to the process with the command no longer need to be described as command parameters. Iа such a parameter is described in the scheme, it will be a Temporary or a Persistence one, depending on which Purpose is specified in the scheme. If the parameter is not described in the scheme, it will be a Temporary one.</li>
<li>The <code>ExecuteCommand</code> and <code>ExecuteCommandAsync</code> methods return information on whether the command has been executed (it may not be executed under certain conditions) and the <code>ProcessInstance</code> state after the execution of a command.</li>
</ul>
<p><strong>The following additional actions must be taken to uprgade to Workflow Engine 2.2:</strong></p>
<ul>
<li>If you use <code>IWorkflowActionProvider</code>, you will need to add 4 new methods to it: <code>IsActionAsync</code>, <code>IsConditionAsync</code>, <code>ExecuteActionAsync</code>, <code>ExecuteConditionAsync</code>. If you do not yet intend to use asynchronous Actions, then the <code>IsActionAsync</code> and <code>IsConditionAsync</code> methods should always return false, whereas <code>ExecuteActionAsync</code> and <code>ExecuteConditionAsync</code> can throw a NotImplementedException.</li>
</ul>
<pre><code class="language-csharp">public bool IsActionAsync(string name)
{
	return false;
}

public bool IsConditionAsync(string name)
{
	return false;
}

public async Task ExecuteActionAsync(string name, ProcessInstance processInstance, WorkflowRuntime runtime, string actionParameter, CancellationToken token)
{
	throw new NotImplementedException();
}

 public async Task&lt;bool&gt; ExecuteConditionAsync(string name, ProcessInstance processInstance, WorkflowRuntime runtime, string actionParameter, CancellationToken token)
{
	throw new NotImplementedException();
}
</code></pre>
<h2>2.1 {#2.1}</h2>
<ul>
<li>Workflow Engine for .NET Core App 1.1 is released. All Workflow Engine functions are supported. This version will be updated simultaneously along the .NET Framework version. 2 persistence providers are currently supported: MS SQL Server and PostgreSQL. Links to NuGet packages and samples can be found <a href="/downloads/net/">here</a>.</li>
<li>Workflow Engine scheme import/export to/from BPMN2 has been added.</li>
<li>Bulk process creation has been added. Now you can create a large amount of processes (100 - 100,000) in significantly less time than when using the <code>CreateInstance</code> method. Use the <code>_runtime.BulkCreateInstance(..)</code> method to do that. Currently, the feature is available in the .NET Framework version of Workflow Engine and supports only MS SQL Server. The list of supported databases will be expanded.</li>
</ul>
<h2>2.0 {#2.0}</h2>
<ul>
<li>Designer UI has been improved, transitions are now linear for better usability</li>
<li>Scheme rendering library <a href="https://github.com/ericdrowell/KineticJS">KineticJS</a> has been replaced with <a href="https://konvajs.github.io/">Konva.js</a></li>
<li><code>WorkflowDesigner.readonlymode()</code>, <code>WorkflowDesigner.printablemode()</code> and <code>WorkflowDesigner.ediatblemode()</code> methods have been added to <code>WorkflowDesigner</code> object in the client. <code>readonlymode</code> makes Designer uneditable. <code>printablemode</code> removes the toolbar, the grid and all controls, zooming designer so that the scheme occupies the entire canvas. This mode can be used to print Designer's viewport to a PDF within a browser. <code>editablemode</code> makes Designer editable.</li>
<li>Designer now allows users to make an autocomplete list for the following fields: <code>Actor.Value</code>, <code>Activity.Implementation.Action parameter</code>, <code>Transition.Condition.ActionParameter</code>. The autocomplete list is being populated server-side via the <code>IDesignerAutocompleteProvider</code> interface and by transferring implementation to the <code>WorkflowRuntime</code> object via <code>_runtime.WithDesignerAutocompleteProvider(provider)</code>.</li>
<li>The <code>GetConditions</code> method has been added to the <code>IWorkflowActionProvider</code> interface. Now, the choice of conditions and actions in Designer can be split.</li>
<li>Parameters of any type not mentioned in the scheme can now be used in Actions' code. The type should be serialized in JSON. Three methods are available: <code>_processInstance.SetParameter(&quot;parameterName&quot;,parameterValue,ParameterPurpose.Persistence)</code>, <code>_processInstance.GetParameter&lt;ParameterType&gt;(&quot;parameterName&quot;)</code> and <code>_processInstance.RemoveParameter(&quot;parameterName&quot;)</code>.</li>
<li>Ability to create Timers with a value which is undefined at the time of creation of a process has been added. <code>Timer.Value == -1</code> means that the current transition will not be executed until the respective timer has a defined value. <code>Timer.Value == 0</code> means that in case the timer connected to a transition does not have a value, this transition shall be processed automatically. Initial value of a timer can be set with the <code>_runtime.NeedTimerValue</code> event.</li>
<li>Ability to modify execution time for timers in running processes has been added. Use methods <code>_runtime.SetTimerValue(processId,timerName,newValue)</code> and <code>_runtime.ResetTimerValue(processId, timerName)</code> to change and reset timer values outside the process. Use methods <code>_runtime.SetTimerValue(processInstance,timerName,newValue)</code> and <code>_runtime.ResetTimerValue(processInstance, timerName)</code> to change and reset timer values from within your Actions.</li>
<li>Newtonsoft.Json version has been changed from 7.0.1 to 9.0.0.</li>
</ul>
<p><strong>The following additional actions must be taken to uprgade to Workflow Engine 2.0:</strong></p>
<ul>
<li>Replace the link to KineticJS with the link to konva.min.js. Konva.js library is included in the ZIP archive and in <code>nuget package WorkflowEngine.NET-Designer</code>.</li>
<li>Update Newtonsoft.Json.dll to 9.0.0. The library is included in the ZIP archive and in <code>nuget package WorkflowEngine.NET-Core</code>.</li>
<li>If you use <code>implementation</code> of <code>IWorkflowActionProvider</code> you should add a <code>public List&lt;string&gt; GetConditions()</code> method to it. It is advisable that the <code>GetActions</code> returns only the list of available Actions, whereas the <code>GetConditions</code> method should return the list of available Conditions. In this case they should be filtered properly in the Designer. However, if you do not want to modify your code, make sure that the <code>GetConditions</code> method throws a <code>NotImplementedException</code>. In this case, everything should work as it used to.</li>
<li>IF you use Oracle, you should run an <code>update_1_5_to_2_0.sql</code> script from the Oracle provider ZIP archive or a NuGet package.</li>
</ul>
<h2>1.5.6 {#1.5.6}</h2>
<ul>
<li>Two new persistence providers were added to WorkflowEngine.NET Redis Provider for <a href="http://redis.io/">Redis</a> and Ignite Provider for <a href="https://ignite.apache.org/">Apache Ignite</a></li>
<li>notrendertoolbar property was added to the Designer object configuration (client side javascript). You can hide toobar in the workflow designer for end users.</li>
<li>Second parameter which allow ignore AutoSchemeUpdate sign of Activity was added to the WorkflowRuntime.UpdateSchemeIfObsolete method.</li>
<li>Several redundat operations related to subprocess features were removed to increase performance.</li>
<li>Conditions are checked for transitions that creating subprocesses.</li>
</ul>
<h2>1.5.5 {#1.5.5}</h2>
<p>In this release several features have been added to simplify the generation of forms based on commands.</p>
<ul>
<li>The sign <code>IsRequired</code> for command parameter. You can take it into account when generating forms, also it is used in the command validation before the execution of command.</li>
<li>The <code>Default value</code> for command parameter. You can access it using <code>CommandParameter.DefaultValue</code> property, after you have received the list of available commands. You can set all command parameters to default value using <code>WorkflowCommand.SetAllParametersToDefault</code> or <code>WorkflowCommand.SetParameterToDefault</code> functions. The Default value must be a valid JSON (wich can be deserialized to type which is specified in the bond Parameter) or will be interpreted as a string.</li>
<li>An <code>autocompete</code> was added in the field <code>Type of Parameter</code> (editing window Parameters). It makes a suugestions about types which can be used such as primitive types (Int32, String etc) or your custom types. Types from assemblies which was registerd using <code>_runtime.RegisterAssemblyForCodeActions</code> function are added in the autocomplete list. To prevent registration or filter the list you can use the last two optional parameters of _runtime.RegisterAssemblyForCodeActions function - ignoreForDesigner and designerTypeFilter.</li>
<li>The <code>Initial values</code> were added for Parameters. You can yse Initial value only for Parameters which have Purpose = Persistence. This values must be a valid JSON (wich can be deserialized to type which is specified in the bond Parameter) or will be interpreted as a string. These values will be set to the process when it is created.</li>
<li>The JSON editor was added for edit <code>Parameter.InitialValue</code> (Parameters window), <code>Command.InputParameters.DefaultValue</code> (Commands window), <code>Actor.Value</code> (Actors window),
<code>Activity.Implementation.ActionParameter</code> (Activity window), <code>Transition.Condition.ActionParameter</code> (Transition window). The JSON editor includes a syntax highlight and Format button. The Format button can be used to format your JSON. Please note that if you use JSON with unquoted property names, you must add reference on <code>json5.js</code> library on Designer page. For Parameter.InitialValue (Parameters window) and Command.InputParameters.DefaultValue (Commands window) the JSON editor aso includes Create button. This button can be used to create an empty object based on Parameter.Type. Designer (on server) uses only parameterless constructor to create the empty object.</li>
<li>There are two new events was added to <code>WorkflowRuntime</code>. Both are occured only in normal execution mode (not in pre-execution). <code>BeforeActivityExecution</code> - is occured after the Runtime has chosen an appropriate transition for execution but before Actions in an Activity were executed. <code>ProcessActivityChanged</code> - is occured after some Activity was executed. You can use <code>ProcessActivityChanged.TransitionalProcessWasCompleted</code> property to ensure that the command (or timer) execution was finished. Using of these events could be more convenient than <code>ProcessStatusChanged</code> in some cases.</li>
<li><code>GetAllActorsForCommandTransitions(ProcessInstance)</code> method was added to <code>WorkflowRuntime</code>. You can use this method to get next potential approvers for current state.</li>
<li>You can change the JSON Serializer settings for Parameters derialization using SetParameterSerializerSettings configuration method.</li>
</ul>
<h2>1.5.4 {#1.5.4}</h2>
<ul>
<li>Schema was added in constructors of all SQL providers. For MsSQL the default schema is &quot;dbo&quot;. For PostgreSql the default schema is &quot;public&quot;. For Oracle the default schema is null.</li>
<li>You are able to specify an interval timer value with milliseconds, seconds, minutes and days. For example &quot;1d 2h 4m 30s&quot; - one day two hours four minutes thirty seconds or &quot;5m 30s&quot;, &quot;14d&quot;, &quot;12h&quot;, &quot;10m&quot;, &quot;10s&quot; etc. You are able to use following names. d, day or days to specify interval in days. h, hour or hours to specify interval in hours. m, minute or minutes to specify interval in minutes. s, second or seconds to specify interval in seconds. ms, millisecond or milliseconds to specify interval in milliseconds. If the interval is specified as just a numeric value, it is interpreted as the interval in milliseconds.</li>
<li>You are able to pass initial parameters of a process by using <code>_runtime.CreateInstance(CreateInstanceParams createInstanceParams)</code> method. Parameters passed in the createInstanceParams.InitialProcessParameters property will be used as initial for parameters of a process.</li>
</ul>
<h2>1.5.3 {#1.5.3}</h2>
<ul>
<li>The JSON serializer used by the engine was changed from <code>ServiceStack.Text to Newtonsoft.JSON</code>. 1.5.3 version of WFE was built with the <code>verion 7.0 of Newtonsoft.JSON</code>.</li>
<li><em>MSSQL provider</em> was rewritten from LINQtoSQL to ordinary SQL queries.</li>
<li>The <em>Parameter</em> window in the designer was implroved. Now you can hide System parameters. They are hidden by default.</li>
<li>Working with types in the <em>Parameter</em> window in the designer was improved. Now you are able to use short type's names such as String, Guid, Int32 etc for primitive types. The type names including namespace for custom types (OptimaJet.Workflow.Core.Model.ActivityDefinition, Business.Approvers etc)- Also you are able to use &lt;&gt; for generic types and [] for arrays.</li>
<li>Fixed a bug in the timers for their correct restart after restart of the workflow runtime.</li>
</ul>
<h2>1.5.2 {#1.5.2}</h2>
<ul>
<li><code>ExecutedActivity</code> and <code>ExecutedTransition</code> properties added in <code>ProcessInstance</code> class. Via them, you can access executed transition and activity during a transitional process.</li>
<li>A scheme of a process downloaded from the designer with not ecoded <em>Code Actions</em>. You can upload a scheme with encoded or not encoded code actions.</li>
<li>The algorithm of sub-process scheme separation improved for it to work properly with the different schemes.</li>
<li><code>GetAvailableCommands</code> method returns distinct commands.</li>
<li>Fixed parsing of the values of the <em>Timers</em> in different cultures</li>
<li>While merging the processes you can access the parameters of a subprocess using the property <code>MergedSubprocessParameters</code> of the <code>ProcessInstance</code> class.</li>
</ul>
